{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation Index","text":"<p>Welcome to the MyResumo Documentation! This index serves as a guide to navigate through the various documentation pages available in this project.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Project Overview</li> <li> <p>Learn about the purpose, features, and structure of the project.</p> </li> <li> <p>Setup Guide</p> </li> <li> <p>Step-by-step instructions to set up the project locally.</p> </li> <li> <p>Contributing Guide</p> </li> <li> <p>Guidelines for contributing to the project, including coding standards and reporting issues.</p> </li> <li> <p>Core Business Logic</p> </li> <li> <p>Detailed explanation of the core functionalities and business logic implemented in the project.</p> </li> <li> <p>AI Integration</p> </li> <li>Insights into how AI is integrated into the project, including models used and key features.</li> </ol>"},{"location":"#how-to-use-this-documentation","title":"How to Use This Documentation","text":"<ul> <li>Click on the links above to navigate to the respective pages.</li> <li>Each page provides detailed information about a specific aspect of the project.</li> <li>Use this index as a starting point to explore the documentation.</li> </ul> <p>For any additional questions or clarifications, feel free to reach out to the project maintainers.</p>"},{"location":"ai_integration/","title":"AI Integration in MyResumo","text":"<p>This document outlines how AI is integrated into the MyResumo project to enhance its functionalities.</p>"},{"location":"ai_integration/#ai-models-used","title":"AI Models Used","text":"<ul> <li>NLP Models:</li> <li>Used for keyword extraction and job description analysis.</li> <li> <p>Identifies key skills and requirements from job descriptions.</p> </li> <li> <p>Recommendation Models:</p> </li> <li>Provides suggestions for improving resume content and structure.</li> <li>Ensures alignment with job descriptions and industry standards.</li> </ul>"},{"location":"ai_integration/#key-features-powered-by-ai","title":"Key Features Powered by AI","text":"<ol> <li>ATS Scoring:</li> <li>Simulates ATS algorithms to evaluate resumes.</li> <li> <p>Provides a score and actionable feedback for improvement.</p> </li> <li> <p>Content Suggestions:</p> </li> <li>Suggests better phrasing, formatting, and content organization.</li> <li> <p>Highlights missing skills or experiences based on job descriptions.</p> </li> <li> <p>Job Description Analysis:</p> </li> <li>Extracts critical information from job descriptions.</li> <li>Identifies trends and patterns to guide resume optimization.</li> </ol>"},{"location":"ai_integration/#implementation-details","title":"Implementation Details","text":"<ul> <li>AI services are abstracted behind clean interfaces in the <code>app/services/ai/</code> module.</li> <li>Prompts and configurations are versioned for consistency and traceability.</li> <li>Logs interactions with AI services for debugging and monitoring purposes.</li> </ul>"},{"location":"ai_integration/#error-handling","title":"Error Handling","text":"<ul> <li>Implements fallbacks for AI service failures.</li> <li>Provides meaningful error messages and alternative solutions.</li> </ul> <p>For more details, refer to the <code>app/services/ai/</code> directory.</p>"},{"location":"business_logic/","title":"Core Business Logic","text":"<p>This document explains the core business logic implemented in the MyResumo project. It provides insights into the key functionalities and their underlying principles.</p>"},{"location":"business_logic/#resume-optimization","title":"Resume Optimization","text":"<p>The primary feature of MyResumo is to optimize resumes for better alignment with job descriptions. This involves:</p> <ol> <li>Keyword Matching:</li> <li>Extracts keywords from job descriptions using natural language processing (NLP).</li> <li> <p>Matches these keywords with the content of the resume to identify gaps.</p> </li> <li> <p>ATS Scoring:</p> </li> <li>Simulates Applicant Tracking System (ATS) scoring by analyzing formatting, keyword density, and section organization.</li> <li> <p>Provides actionable feedback to improve the resume's ATS compatibility.</p> </li> <li> <p>AI-Powered Suggestions:</p> </li> <li>Leverages AI models to suggest improvements in phrasing, structure, and content.</li> <li>Ensures the resume highlights relevant skills and experiences.</li> </ol>"},{"location":"business_logic/#pdf-and-latex-resume-generation","title":"PDF and LaTeX Resume Generation","text":"<ul> <li>Converts optimized resumes into professional PDF formats using LaTeX templates.</li> <li>Supports multiple templates to cater to different industries and preferences.</li> </ul>"},{"location":"business_logic/#token-usage-tracking","title":"Token Usage Tracking","text":"<ul> <li>Monitors the usage of AI tokens to ensure fair and efficient resource allocation.</li> <li>Implements limits and notifications to prevent overuse.</li> </ul>"},{"location":"business_logic/#job-description-analysis","title":"Job Description Analysis","text":"<ul> <li>Analyzes job descriptions to extract key requirements and skills.</li> <li>Provides insights into the most critical aspects of the job for better resume alignment.</li> </ul>"},{"location":"business_logic/#error-handling-and-edge-cases","title":"Error Handling and Edge Cases","text":"<ul> <li>Handles scenarios like empty inputs, invalid file formats, and unsupported languages gracefully.</li> <li>Ensures robust error messages and fallback mechanisms.</li> </ul> <p>For detailed implementation, refer to the respective modules in the <code>app/</code> directory.</p>"},{"location":"contributing/","title":"Contributing to MyResumo","text":"<p>Thank you for considering contributing to MyResumo! This document outlines the guidelines for contributing to the project.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":"<ol> <li>Fork the repository and create a new branch for your feature or bugfix.</li> <li>Make your changes, ensuring they follow the project's coding standards.</li> <li>Write tests for your changes and ensure all tests pass.</li> <li>Submit a pull request with a clear description of your changes.</li> </ol>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":"<ul> <li>Follow PEP 8 for Python code.</li> <li>Use type annotations and docstrings.</li> <li>Write meaningful commit messages (see <code>CONTRIBUTING.md</code> for examples).</li> </ul>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>If you encounter any issues, please report them by creating a new issue in the GitHub repository. Provide as much detail as possible, including steps to reproduce the issue.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please adhere to the project's code of conduct when contributing. Be respectful and constructive in your interactions.</p>"},{"location":"overview/","title":"Project Overview","text":"<p>Welcome to the MyResumo project! This document provides an overview of the project, its purpose, and its key components.</p>"},{"location":"overview/#purpose","title":"Purpose","text":"<p>MyResumo is designed to help users create, optimize, and manage resumes efficiently. It leverages AI to provide insights and recommendations for improving resumes based on job descriptions.</p>"},{"location":"overview/#key-features","title":"Key Features","text":"<ul> <li>Resume creation and optimization</li> <li>AI-powered ATS scoring</li> <li>Job description analysis</li> <li>PDF and LaTeX resume generation</li> </ul>"},{"location":"overview/#project-structure","title":"Project Structure","text":"<p>The project is organized into several key directories: - <code>app/</code>: Contains the main application code, including APIs, services, and utilities. - <code>data/</code>: Includes sample data, templates, and responses. - <code>scripts/</code>: Contains utility scripts for development and setup. - <code>doc/</code>: Official documentation for contributors.</p> <p>For more details, refer to the specific documentation files in this folder.</p>"},{"location":"portainer-rebuild/","title":"Portainer Rebuild Configuration","text":"<p>This document explains the configuration to force Portainer to rebuild the application container after changes are pushed to GitHub.</p>"},{"location":"portainer-rebuild/#overview","title":"Overview","text":"<p>By default, Docker and Portainer use caching mechanisms to speed up builds. While this is efficient for development, it can sometimes cause issues when you want to ensure that all changes are properly incorporated into a new build.</p> <p>The following mechanisms have been implemented to force a complete rebuild:</p>"},{"location":"portainer-rebuild/#1-version-file","title":"1. Version File","text":"<p>A <code>version.txt</code> file is used to invalidate Docker's build cache. This file is: - Updated with a timestamp and commit hash before each build - Copied early in the Dockerfile to invalidate the cache for subsequent steps</p>"},{"location":"portainer-rebuild/#2-no-cache-build-options","title":"2. No-Cache Build Options","text":"<p>Several mechanisms force Docker to build without using cache: - The <code>update-portainer.sh</code> script uses the <code>--no-cache</code> flag when building - A <code>docker-compose.override.yml</code> file sets <code>no_cache: true</code> for local development - The GitHub workflow has been modified to use <code>no-cache: true</code></p>"},{"location":"portainer-rebuild/#3-container-replacement","title":"3. Container Replacement","text":"<p>Instead of just restarting the container, the update script: 1. Stops the current container 2. Removes it completely 3. Rebuilds the image from scratch 4. Creates a new container</p>"},{"location":"portainer-rebuild/#usage","title":"Usage","text":""},{"location":"portainer-rebuild/#manual-deployment","title":"Manual Deployment","text":"<p>To manually trigger a rebuild:</p> <pre><code>./scripts/update-portainer.sh\n</code></pre>"},{"location":"portainer-rebuild/#automatic-deployment","title":"Automatic Deployment","text":"<p>The GitHub workflow will automatically: 1. Update the version file 2. Build without cache 3. Push to the GitHub Container Registry</p>"},{"location":"portainer-rebuild/#troubleshooting","title":"Troubleshooting","text":"<p>If changes are still not appearing after a push:</p> <ol> <li>SSH into the server</li> <li>Navigate to the repository directory</li> <li>Run <code>git pull</code> to ensure the latest code is present</li> <li>Run <code>docker-compose build --no-cache</code> to force a rebuild</li> <li>Run <code>docker-compose down &amp;&amp; docker-compose up -d</code> to restart the containers</li> </ol>"},{"location":"setup/","title":"Project Setup","text":"<p>This document provides instructions for setting up the MyResumo project locally.</p>"},{"location":"setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>Virtual environment tool (e.g., <code>venv</code>, <code>poetry</code>, or <code>pipenv</code>)</li> <li>Docker (optional, for containerized development)</li> </ul>"},{"location":"setup/#steps","title":"Steps","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/AnalyticAce/MyResumo.git\ncd MyResumo\n</code></pre></p> </li> <li> <p>Create and activate a virtual environment:    <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n</code></pre></p> </li> <li> <p>Install dependencies:    <pre><code>pip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Run the development server:    <pre><code>python app/main.py\n</code></pre></p> </li> <li> <p>Access the application at <code>http://127.0.0.1:8000</code>.</p> </li> </ol> <p>For Docker setup, refer to the <code>Dockerfile</code> and <code>docker-compose</code> documentation.</p>"},{"location":"updating-portainer/","title":"Updating the Application on Portainer","text":"<p>This document explains how to update the application running on Portainer on the remote server.</p>"},{"location":"updating-portainer/#prerequisites","title":"Prerequisites","text":"<ol> <li>SSH access to the remote server</li> <li>Access to the Portainer web interface</li> <li>Knowledge of the application container name</li> </ol>"},{"location":"updating-portainer/#method-1-using-the-portainer-web-interface","title":"Method 1: Using the Portainer Web Interface","text":"<ol> <li>Connect to the Portainer web interface at http://192.168.7.10:9000</li> <li>Log in with your credentials</li> <li>Navigate to the Containers section</li> <li>Find the application container (usually named \"myresumo\" or similar)</li> <li>Click on the container to view its details</li> <li>Click on the \"Recreate\" button to recreate the container with the latest image</li> <li>If needed, click on the \"Restart\" button to restart the container</li> </ol>"},{"location":"updating-portainer/#method-2-using-ssh","title":"Method 2: Using SSH","text":"<ol> <li> <p>Connect to the remote server using SSH:    <pre><code>ssh root@192.168.7.10\n</code></pre>    Password: <code>Lokifish123</code></p> </li> <li> <p>Find the application container:    <pre><code>docker ps | grep -i myresumo\n</code></pre></p> </li> <li> <p>Get the container ID:    <pre><code>CONTAINER_ID=$(docker ps | grep -i myresumo | awk '{print $1}')\n</code></pre></p> </li> <li> <p>Find the GitHub repository directory:    <pre><code>find / -name .git -type d 2&gt;/dev/null | grep -v '/\\.' | grep -i myresumo\n</code></pre></p> </li> <li> <p>Navigate to the GitHub repository directory:    <pre><code>cd /path/to/repository\n</code></pre></p> </li> <li> <p>Pull the latest code from GitHub:    <pre><code>git pull\n</code></pre></p> </li> <li> <p>Restart the container:    <pre><code>docker restart $CONTAINER_ID\n</code></pre></p> </li> <li> <p>Check the status of the container:    <pre><code>docker ps | grep $CONTAINER_ID\n</code></pre></p> </li> </ol>"},{"location":"updating-portainer/#method-3-using-the-connect-script","title":"Method 3: Using the Connect Script","text":"<p>We've created a script to connect to the remote server. To use it:</p> <ol> <li> <p>Run the script:    <pre><code>./scripts/connect-to-server.sh\n</code></pre></p> </li> <li> <p>Once connected, follow the steps in Method 2 from step 2 onwards.</p> </li> </ol>"},{"location":"updating-portainer/#troubleshooting","title":"Troubleshooting","text":"<p>If you're still not seeing your changes after updating the application, try the following:</p> <ol> <li> <p>Check if the container is using volume mounts:    <pre><code>docker inspect $CONTAINER_ID | grep -A 10 \"Mounts\"\n</code></pre></p> </li> <li> <p>If the container is using volume mounts, check if the mounted directories contain the latest code:    <pre><code>ls -la /path/to/mounted/directory\n</code></pre></p> </li> <li> <p>If the mounted directories don't contain the latest code, you may need to manually copy the files:    <pre><code>cp -r /path/to/repository/* /path/to/mounted/directory/\n</code></pre></p> </li> <li> <p>Restart the container again:    <pre><code>docker restart $CONTAINER_ID\n</code></pre></p> </li> </ol>"},{"location":"updating-portainer/#best-practices","title":"Best Practices","text":"<ol> <li>Always test your changes locally before pushing them to GitHub</li> <li>Use a staging environment to test changes before deploying to production</li> <li>Consider setting up a CI/CD pipeline to automate the deployment process</li> <li>Use Docker volumes for development to avoid having to rebuild the container for every change</li> </ol>"},{"location":"updating-remote-server/","title":"Updating the Remote Server","text":"<p>This document explains how to update the remote server with the latest code changes.</p>"},{"location":"updating-remote-server/#problem","title":"Problem","text":"<p>When you make changes to the code locally, commit them to GitHub, and push them to the remote repository, the changes are not automatically reflected on the remote server. This is because the Docker container on the remote server is built with the code at build time, not at runtime.</p>"},{"location":"updating-remote-server/#solution","title":"Solution","text":"<p>To update the remote server with the latest code changes, you need to:</p> <ol> <li>Connect to the remote server</li> <li>Pull the latest code from GitHub</li> <li>Rebuild the Docker container</li> <li>Restart the container</li> </ol>"},{"location":"updating-remote-server/#manual-update-process","title":"Manual Update Process","text":"<ol> <li> <p>SSH into the remote server:    <pre><code>ssh root@192.168.7.10\n</code></pre></p> </li> <li> <p>Navigate to the project directory:    <pre><code>cd /opt/myresumo  # Adjust this path as needed\n</code></pre></p> </li> <li> <p>Pull the latest code from GitHub:    <pre><code>git pull\n</code></pre></p> </li> <li> <p>Rebuild the Docker container:    <pre><code>docker-compose build --no-cache\n</code></pre></p> </li> <li> <p>Restart the container:    <pre><code>docker-compose down\ndocker-compose up -d\n</code></pre></p> </li> <li> <p>Check the status of the container:    <pre><code>docker ps | grep myresumo\n</code></pre></p> </li> </ol>"},{"location":"updating-remote-server/#automated-update-script","title":"Automated Update Script","text":"<p>We've created a script to automate this process. The script is located at <code>scripts/update-remote.sh</code>. To use it:</p> <ol> <li>Edit the script to set the correct values for:</li> <li><code>REMOTE_SERVER</code>: The IP address of the remote server</li> <li><code>REMOTE_USER</code>: The username to use for SSH</li> <li><code>REMOTE_DIR</code>: The directory where the project is located on the remote server</li> <li> <p><code>CONTAINER_NAME</code>: The name of the Docker container</p> </li> <li> <p>Run the script:    <pre><code>./scripts/update-remote.sh\n</code></pre></p> </li> </ol>"},{"location":"updating-remote-server/#troubleshooting","title":"Troubleshooting","text":"<p>If you're still not seeing your changes after updating the remote server, check the following:</p> <ol> <li> <p>Make sure your changes are committed and pushed to GitHub:    <pre><code>git status\ngit log -1\n</code></pre></p> </li> <li> <p>Make sure the remote server is pulling from the correct branch:    <pre><code>git branch -v\n</code></pre></p> </li> <li> <p>Check the Docker container logs for any errors:    <pre><code>docker logs myresumo\n</code></pre></p> </li> <li> <p>Check if the container is using the correct volume mounts:    <pre><code>docker inspect myresumo\n</code></pre></p> </li> </ol>"},{"location":"updating-remote-server/#best-practices","title":"Best Practices","text":"<ol> <li>Always test your changes locally before pushing them to GitHub</li> <li>Use a staging environment to test changes before deploying to production</li> <li>Consider setting up a CI/CD pipeline to automate the deployment process</li> <li>Use Docker volumes for development to avoid having to rebuild the container for every change</li> </ol>"},{"location":"versioning/","title":"Versioning System","text":"<p>MyResumo uses semantic versioning (SemVer) for version management. This document explains how the versioning system works and how to use it.</p>"},{"location":"versioning/#semantic-versioning","title":"Semantic Versioning","text":"<p>We follow the Semantic Versioning 2.0.0 specification. Version numbers are in the format of <code>MAJOR.MINOR.PATCH</code>:</p> <ul> <li>MAJOR: Incremented for incompatible API changes</li> <li>MINOR: Incremented for new functionality in a backward-compatible manner</li> <li>PATCH: Incremented for backward-compatible bug fixes</li> </ul>"},{"location":"versioning/#version-files","title":"Version Files","text":"<p>The version is stored in multiple places to ensure consistency:</p> <ol> <li><code>app/version.py</code> - The central version file</li> <li><code>pyproject.toml</code> - Poetry package version</li> <li><code>app/__init__.py</code> - Python package version</li> <li><code>package.json</code> - Node.js package version</li> </ol> <p>The <code>app/version.py</code> file is the source of truth for the application version.</p>"},{"location":"versioning/#automatic-version-bumping","title":"Automatic Version Bumping","text":"<p>We use GitHub Actions and python-semantic-release to automatically bump the version based on commit messages. The workflow is defined in <code>.github/workflows/version-bump.yml</code>.</p>"},{"location":"versioning/#how-it-works","title":"How It Works","text":"<ol> <li>When code is pushed to the <code>main</code> branch, the workflow checks the commit messages</li> <li>Based on the commit messages, it determines whether to bump the major, minor, or patch version</li> <li>It updates all version files and creates a new Git tag</li> <li>It creates a GitHub release with the changelog</li> </ol>"},{"location":"versioning/#commit-message-format","title":"Commit Message Format","text":"<p>We use the Angular commit message format to determine the version bump:</p> <ul> <li><code>fix: ...</code> - Patch version bump (bug fixes)</li> <li><code>feat: ...</code> - Minor version bump (new features)</li> <li><code>feat!: ...</code> or <code>fix!: ...</code> or any commit with <code>BREAKING CHANGE:</code> in the body - Major version bump</li> </ul> <p>Examples: - <code>fix: correct typo in homepage</code> - Bumps patch version (e.g., 1.0.0 -&gt; 1.0.1) - <code>feat: add new resume template</code> - Bumps minor version (e.g., 1.0.1 -&gt; 1.1.0) - <code>feat!: redesign API endpoints</code> - Bumps major version (e.g., 1.1.0 -&gt; 2.0.0)</p>"},{"location":"versioning/#manual-version-updates","title":"Manual Version Updates","text":"<p>In case you need to update the version manually:</p> <ol> <li>Update <code>app/version.py</code></li> <li>Update <code>pyproject.toml</code></li> <li>Update <code>app/__init__.py</code></li> <li>Update <code>package.json</code></li> </ol> <p>Then commit with a message like <code>chore(release): update version to X.Y.Z</code>.</p>"},{"location":"versioning/#displaying-the-version","title":"Displaying the Version","text":"<p>The application version is displayed in the footer of every page. It's also available in the <code>/health</code> endpoint response.</p>"},{"location":"versioning/#version-information-in-code","title":"Version Information in Code","text":"<p>To access the version in code:</p> <pre><code>from app.version import __version__, get_version_info\n\n# Get the version string\nprint(__version__)  # e.g., \"2.0.0\"\n\n# Get detailed version information\nversion_info = get_version_info()\nprint(version_info)  # Dictionary with version components\n</code></pre>"}]}